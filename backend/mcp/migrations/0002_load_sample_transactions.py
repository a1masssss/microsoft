# Generated by Django 5.2.8 on 2025-11-15 16:19

from django.db import migrations
import pandas as pd
from pathlib import Path
from django.utils import timezone
import pytz


def load_sample_data(apps, schema_editor):
    """
    Load 100k sample transactions from Parquet file.
    This runs automatically when you do 'python manage.py migrate'
    """
    Transaction = apps.get_model('mcp', 'Transaction')
    
    # Check if data already exists
    if Transaction.objects.exists():
        print(f"‚ö†Ô∏è  Transactions already exist ({Transaction.objects.count():,} records). Skipping data load.")
        return
    
    # Find the parquet file
    migration_dir = Path(__file__).resolve().parent.parent
    parquet_file = migration_dir / 'dataset' / 'sample_100k.parquet'
    
    if not parquet_file.exists():
        print(f"‚ö†Ô∏è  Sample data file not found: {parquet_file}")
        print("   Run: python manage.py load_transactions --limit 100000")
        return
    
    print(f"üì¶ Loading sample transaction data from {parquet_file.name}...")
    
    # Read parquet file
    df = pd.read_parquet(parquet_file)
    total_records = len(df)
    print(f"   Found {total_records:,} records to import")
    
    # Prepare batch insertion
    batch_size = 5000
    batch = []
    inserted_count = 0
    
    for idx, row in df.iterrows():
        try:
            # Convert timestamp to timezone-aware datetime
            ts = row['transaction_timestamp']
            if pd.notna(ts):
                ts = timezone.make_aware(ts.to_pydatetime(), timezone=pytz.UTC) if ts.tzinfo is None else ts
            
            # Create Transaction object
            transaction_obj = Transaction(
                transaction_id=str(row['transaction_id']),
                transaction_timestamp=ts,
                card_id=int(row['card_id']) if pd.notna(row['card_id']) else 0,
                expiry_date=str(row['expiry_date']) if pd.notna(row['expiry_date']) else '',
                issuer_bank_name=str(row['issuer_bank_name']) if pd.notna(row['issuer_bank_name']) else '',
                merchant_id=int(row['merchant_id']) if pd.notna(row['merchant_id']) else 0,
                merchant_mcc=int(row['merchant_mcc']) if pd.notna(row['merchant_mcc']) else 0,
                mcc_category=str(row['mcc_category']) if pd.notna(row['mcc_category']) else '',
                merchant_city=str(row['merchant_city']) if pd.notna(row['merchant_city']) else '',
                transaction_type=str(row['transaction_type']) if pd.notna(row['transaction_type']) else '',
                transaction_amount_kzt=float(row['transaction_amount_kzt']) if pd.notna(row['transaction_amount_kzt']) else 0.0,
                original_amount=float(row['original_amount']) if pd.notna(row['original_amount']) else None,
                transaction_currency=str(row['transaction_currency']) if pd.notna(row['transaction_currency']) else '',
                acquirer_country_iso=str(row['acquirer_country_iso']) if pd.notna(row['acquirer_country_iso']) else '',
                pos_entry_mode=str(row['pos_entry_mode']) if pd.notna(row['pos_entry_mode']) else '',
                wallet_type=str(row['wallet_type']) if pd.notna(row['wallet_type']) else None,
            )
            batch.append(transaction_obj)
            
            # Insert batch when it reaches batch_size
            if len(batch) >= batch_size:
                Transaction.objects.bulk_create(batch, ignore_conflicts=True)
                inserted_count += len(batch)
                progress = (inserted_count / total_records) * 100
                print(f'   Progress: {inserted_count:,}/{total_records:,} ({progress:.1f}%)')
                batch = []
                
        except Exception as e:
            print(f"   ‚ö†Ô∏è  Error processing row {idx}: {e}")
    
    # Insert remaining batch
    if batch:
        Transaction.objects.bulk_create(batch, ignore_conflicts=True)
        inserted_count += len(batch)
    
    print(f"‚úÖ Successfully loaded {inserted_count:,} transaction records!")


def reverse_load_data(apps, schema_editor):
    """
    Remove all transactions when migrating backwards
    """
    Transaction = apps.get_model('mcp', 'Transaction')
    count = Transaction.objects.count()
    Transaction.objects.all().delete()
    print(f"üóëÔ∏è  Deleted {count:,} transactions")


class Migration(migrations.Migration):

    dependencies = [
        ('mcp', '0001_initial'),
    ]

    operations = [
        migrations.RunPython(load_sample_data, reverse_load_data),
    ]
